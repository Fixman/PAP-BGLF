\newpage{}
\section{Problema C: Cortes programados}
\textbf{Peso del ejercicio: 9}
\subsection{Descripción del problema}
Dada una ciudad con $N$ esquinas y $M$ calles bidereccionales que conectan 
pares de esquinas, donde se puede viajar entre cualquier par de esquinas 
usando las calles, se pide responder una serie de queries de varios tipos: 

\begin{itemize}
\item Tipo A: dadas 2 esquinas $e_1$ y $e_2$, dar la cantidad de calles tales que, 
si cortáramos únicamente esa calle, impediría viajar desde $e_1$ hasa $e_2$. 
\item Tipo B: dada una calle, devolver si existen al menos 2 esquinas entre las 
que dejaría de haber camino si cortáramos la calle. 
\item Tipo C: dada una esquina $e$, devolver la cantidad de esquinas $e_2$ tales que, 
de cortar una sola calle cualquiera, seguiría habiendo camino entre $e_1$ y $e_2$.
\end{itemize}

Se nos pide diseñar un algoritmo que resuelva el problema en complejidad temporal 
$\bigO(M + MQ_A + Q_B + Q_C)$, donde $Q_A$, $Q_B$ y $Q_C$ son las 
queries de tipo A, B y C respectivamente. 

\subsection{Soluciones al problema}
Modelaremos la ciudad como un grafo, de la manera clásica, donde los nodos 
serán las esquinas de la ciudad, y las aristas serán las calles (esto 
tiene sentido porque las calles conectan \textit{pares} de esquinas). 
Como sabemos que entre todo par de esquinas hay un camino, esto quiere 
decir que el grafo que obtenemos es conexo, y por tanto 
además $\bigO(N) \in \bigO(M)$.

Para resolver el problema, lo que haremos será calcular los \textbf{puentes} 
en el grafo resultante, y responderemos las queries utilizando información 
que obtendremos en base a los puentes. 

Veamos cómo se pueden responder los distintos tipos de queries usando 
los puentes el grafo: 

\begin{itemize}
\item Tipo A: La query nos habla de aristas que al ser removidas individualmente 
impedirían llegar desde $e_1$ hasta $e_2$. De alguna manera nos habla de los puentes 
del grafo, porque esas son las aristas que al ser removidas aumentan la cantidad de 
componentes conexas y cortan caminos entre nodos. 

De modo que la query nos habla de los 
puentes, pero no de todos, sino de \textbf{los puentes que se encuentran 
en un camino simple desde $e_1$ hasta $e_2$}. 

Si bien puede haber más de un camino simple entre $e_1$ y $e_2$, \textbf{no pueden 
existir 2 caminos simples que usen distintos puentes}. Si existiesen 2, entonces 
tendría que haber un ciclo conteniendo a esos puentes, lo cual es un absurdo. 
De modo que los puentes en un camino simple de $e_1$ a $e_2$ son únicos, y es 
claro que cumplen con la condición que buscamos porque necesariamente al remover 
uno quedan separados $e_1$ y $e_2$, de lo contrario habría otro camino que los 
mantiene conectados y esto haría que el puente pertenezca a un ciclo, que también 
es un absurdo. 

Para responder las queries entonces teniendo los puentes del grafo precomputados 
podemos encontrar un camino simple de $e_1$ a $e_2$ con un BFS, y luego 
iterar sobre dicho camino y contar la cantidad de puentes en el. El BFS 
siempre encuentra camino (porque el grafo es conexo) y tiene complejidad 
$\bigO(N+M) = \bigO(M)$. Luego $Q_A$ queries de tipo A tienen complejidad 
$\bigO(MQ_A)$. 

\item Tipo B: la query nos pide devolver para una arista dada, si al 
removerla hay al menos 2 nodos que quedan desconectados. Como todos 
los nodos empiezan conectados por ser el grafo conexo, la única manera de que 
al remover una arista se desconecten nodos es que aumente la cantidad de componentes 
conexas, y esto ocurre únicamente al remover un puente (por definición). 

Teniendo los puentes del grafo precomputados, dada una arista podemos responder 
en $\bigO(1)$ si es o no un puente, luego $Q_B$ queries de tipo B tienen complejidad 
$\bigO(Q_B)$. 

\item Tipo C:
\end{itemize}

\subsection{Algoritmo}
\newpage
\subsection{Código de la solución}
\lstinputlisting[numbers = left]{../src/c/c.cpp}
