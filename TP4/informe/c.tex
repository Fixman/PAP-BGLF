\newpage{}
\section{Problema C: Construyendo murallas}
\textbf{Peso del ejercicio: 10}

\subsection{Descripción del problema}
% intro, contar que onda
Se nos dan $H$ puntos que representan lugares históricos de un reino, 
y otros $E$ puntos que representan edificios de un reino enemigo. 

Se quieren encerrar dentro de una muralla algunos puntos de los lugares históricos, 
con las condiciones de que no quede ningún punto enemigo dentro de la muralla, 
y que la muralla debe ser un polígono convexo. Además queremos maximizar la cantidad 
de lugares históricos que quedan dentro de la muralla. \\

Por ejemplo, si en la figura los puntos con marcados con $H$ son lugares históricos 
y los marcados con $E$ son edificios enemigos, la solución óptima estaría dada por 
el polígono marcado con líneas, cuyo valor sería X. 
% TODO dibujito con ejemplo 

Siendo $N = H + E$, se nos pide encontrar un algoritmo que sea polinomial, en el mejor 
de los casos con complejidad temporal $O(N^5)$ u $O(N^4)$. Se asume además que no existirán 
tres puntos alineados en la entrada. \\

\textbf{Solución propuesta}

La solución que proponemos tiene complejidad temporal de $O(N^4)$, se basará fuertemente 
en la utilización de triángulos. Para empezar, enunciamos algunas propiedades y observaciones 
útiles que serán importantes para entender la solución. 

\subsection{Observaciones importantes}
% triangulacion, triangulos faciles
\begin{itemize}
\item El polígono que debemos hallar es un polígono convexo, sabemos que todo 
polígono convexo admite una triangulación. En particular, también admite una triangulación 
en la que todos las diagonales salen de un mismo vértice. Llamaremos a este vértice \textit{pivote} 
para futuras referencias. 
\item Dados tres puntos (y asumiendo que no habrá 3 puntos alineados), es unívoco el triángulo que se 
forma y además es no degenerado siempre. El hecho de que sea unívoco no es cierto para polígonos más 
grandes, y además hará más simple el algoritmo. 
\item Queremos además encontrar un polígono convexo que contenga la mayor cantidad de puntos \textit{buenos} 
(los lugares históricos) y que no incluya ningún punto \textit{malo} (los edificios enemigos). 
Dado un triángulo, y otro punto (que no sea ninguno de sus vértices), es fácil verificar si el punto 
cae dentro o fuera del triángulo (más adelante daremos detalles de esto). Esta información y el 
hecho que sea simple, nos ayudarán con el algoritmo. 
\end{itemize}

\subsection{Explicación del algoritmo}
Usando estas observaciones construiremos nuestro algoritmo. La idea del mismo tiene elementos similares 
con el algoritmo de Graham para hallar una cápsula convexa dados un conjunto de puntos. \\

\textbf{Preproceso}

Primero lo que haremos será tomar todos los triángulos formados por tres puntos buenos distintos, 
y para cada uno calcular cuántos otros puntos buenos caen dentro del triángulo y si cae algún punto malo 
también. Guardaremos esta información para cada triángulo, dado que luego la utilizaremos en 
el cálculo de la solución. Llamaremos \textit{puntaje} de un triángulo a la cantidad de puntos buenos 
que caigan dentro del triángulo, y diremos que un triángulo es \textit{válido} si no tiene 
ningún punto malo en su interior. 

Iterar sobre todos los triángulos formados por puntos buenos tiene complejidad 
$O(N^3)$ y se puede computar en tiempo constante si un punto cae dentro de un triángulo (más adelante 
explicaremos cómo). 
De modo que todo este preproceso puede hacerse en $O(N^4)$.\\

\textbf{Cálculo de la solución}

Tomamos un punto cualquiera que supondremos será el \textit{pivote} 
del polígono de nuestra solución. Con el resto de los puntos, trateremos de formar polígonos 
convexos usando triángulos que usen el \textit{pivote} como vértice. Como tenemos fijo uno 
de los puntos (el \textit{pivote}) hay en total $O(N^2)$ triángulos sobre los que iterar. 
Para facilitar el chequeo de que los polígonos resultantes sean convexos, 
sólo tomaremos puntos que se encuentren más abajo que el \textit{pivote}.

Entonces, el algoritmo va recorriendo los triángulos (o bien, los 2 puntos que formarían el triángulo 
con el \textit{pivote}) en orden según el ángulo que forman con el \textit{pivote}. De esta forma, 
se puede plantear un algoritmo de programación dinámica que calcula, para cada triángulo $T$ que 
usa el \textit{pivote}: cuál es el mejor puntaje acumulado que se puede lograr armando 
un polígono convexo (y sin puntos malos), si el último triángulo que se agrega al polígono 
es $T$. Llamamos a este valor \texttt{dp[T]}.

Para calcular esto para todo triángulo $T$, debemos tener calculado previamente también 
\texttt{dp[T']} para los $T'$ triángulos que se encuentren antes según el ángulo con el 
\textit{pivote}, donde $T'$ sería el anteúltimo triángulo del polígono (justo antes que $T$). 
Es por esto que recorremos los triángulos en orden en algún sentido (horario u 
antihorario), cuando querramos calcular \texttt{dp[T]} tendremos calculado ya el valor de los triángulos 
anteriores. 

Es claro que como $T'$ debe ir inmediatamente antes que $T$, no cualquier triángulo puede 
servir como $T'$, debe cumplir entonces que: 
\begin{itemize}
\item $T'$ debe ser \textit{adyacente} a $T$, en el sentido que debe compartir un lado, de manera 
que los triángulos se ``peguen bien''. Dicho de otra forma, si $T$ está formado por los puntos $i$ y $j$ 
(con $i$ antes que $j$ según el \textit{pivote}), entonces $T'$ debe estar formado por $k$ e $i$ 
(con $k$ antes que $i$). 
\item Siempre los triángulos que miramos, tanto $T$ como $T'$ deben ser \textit{válidos} (no 
contener puntos malos). 
\item Se debe mantener la convexidad del polígono. Para esto, basta con mirar (similar a cómo 
funciona el algoritmo de Graham) que los puntos $k$, $i$ y $j$ formen un ángulo convexo (menor a 180 grados). 
De esta forma, todos los ángulos interiores del polígono resultante serán menores a 180 grados, y 
por tanto el polígono será convexo. 
\end{itemize}

% TODO dibujo aqui con explicacion

\subsection{Pseudocódigo}

\textbf{Correctitud del algoritmo}\\

\subsection{Detalles sobre la implementación}
% diferencia entre N^4 y N^5, como hacerlo 
% explicar el bind? 
% que los puntos tienen coordenadas enteras nomas

\subsection{Análisis de complejidad}
% ganar

\newpage
\subsection{Código de la solución}
\lstinputlisting[numbers = left]{../src/ej3/ej3.cpp}
