\newpage{}
\section{Problema C: }
\textbf{Peso del ejercicio: 10}

\subsection{Descripción del problema}
% intro, contar que onda
Se nos dan $H$ puntos que representan lugares históricos de un reino, 
y otros $E$ puntos que representan edificios de un reino enemigo. 

Se quieren encerrar dentro de una muralla algunos puntos de los lugares históricos, 
con las condiciones de que no quede ningún punto enemigo dentro de la muralla, 
y que la muralla debe ser un polígono convexo. Además queremos maximizar la cantidad 
de lugares históricos que quedan dentro de la muralla. \\

Por ejemplo, si en la figura los puntos con marcados con $H$ son lugares históricos 
y los marcados con $E$ son edificios enemigos, la solución óptima estaría dada por 
el polígono marcado con líneas, cuyo valor sería X. 
% TODO dibujito con ejemplo 

Siendo $N = H + E$, se nos pide encontrar un algoritmo que sea polinomial, en el mejor 
de los casos con complejidad temporal $O(N^5)$ u $O(N^4)$. Se asume además que no existirán 
tres puntos alineados en la entrada. 

\subsection{Solución propuesta}

La solución que proponemos tiene complejidad temporal de $O(N^4)$, se basará fuertemente 
en la utilización de triángulos. Para empezar, enunciamos algunas propiedades y observaciones 
útiles que serán importantes para entender la solución. 

\subsubsection{Observaciones importantes}
% triangulacion, triangulos faciles
\begin{itemize}
\item El polígono que debemos hallar es un polígono convexo, sabemos que todo 
polígono convexo admite una triangulación. En particular, también admite una triangulación 
en la que todos las diagonales salen de un mismo vértice. Llamaremos a este vértice \textit{pivote} 
para futuras referencias. 
\item Dados tres puntos (y asumiendo que no habrá 3 puntos alineados), es unívoco el triángulo que se 
forma y además es no degenerado siempre. El hecho de que sea unívoco no es cierto para polígonos más 
grandes, y además hará más simple el algoritmo. 
\item Queremos además encontrar un polígono convexo que contenga la mayor cantidad de puntos \textit{buenos} 
(los lugares históricos) y que no incluya ningún punto \textit{malo} (los edificios enemigos). 
Dado un triángulo, y otro punto (que no sea ninguno de sus vértices), es fácil verificar si el punto 
cae dentro o fuera del triángulo (más adelante daremos detalles de esto). Esta información y el 
hecho que sea simple, nos ayudarán con el algoritmo. 
\end{itemize}

\subsubsection{Algoritmo}
% mas dibujitos
Usando estas observaciones construiremos nuestro algoritmo. La idea del mismo tiene elementos similares 
con el algoritmo de Graham para hallar una cápsula convexa dados un conjunto de puntos. \\

\textbf{Preproceso}

Primero lo que haremos será tomar todos los triángulos formados por tres puntos buenos distintos, 
y para cada uno calcular cuántos otros puntos buenos caen dentro del triángulo y si cae algún punto malo 
también. Guardaremos esta información para cada triángulo, dado que luego la utilizaremos en 
el cálculo de la solución. Llamaremos \textit{puntaje} de un triángulo a la cantidad de puntos buenos 
que caigan dentro del triángulo, y diremos que un triángulo es \textit{válido} si no tiene 
ningún punto malo en su interior. 

Iterar sobre todos los triángulos formados por puntos buenos tiene complejidad 
$O(N^3)$ y se puede computar en tiempo constante si un punto cae dentro de un triángulo (más adelante 
explicaremos cómo). 
De modo que todo este preproceso puede hacerse en $O(N^4)$.\\

\textbf{Cálculo de la solución}

La idea será, tomar un punto cualquiera que supondremos será el \textit{pivote} 
del polígono de nuestra solución. Con el resto de los puntos, trateremos de formar polígonos 
convexos usando triángulos que usen el \textit{pivote} como vértice. 



Para facilitar el chequeo de 
que los polígonos resultantes sean convexos, sólo tomaremos puntos que se encuentren más abajo que el 
\textit{pivote} (de este modo ...)


\textbf{Correctitud del algoritmo}\\

\subsubsection{Detalles sobre la implementación}
% diferencia entre N^4 y N^5, como hacerlo 
% explicar el bind? 
% que los puntos tienen coordenadas enteras nomas

\subsubsection{Análisis de complejidad}
% ganar

\newpage
\subsection{Código de la solución}
\lstinputlisting[numbers = left]{../src/ej3/ej3.cpp}
