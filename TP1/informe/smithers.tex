\newpage{}
\section{El error de Smithers}
\subsection{Descripción del problema}
Dadas una matriz $M\in Z_p$ ($p$ es 10007, el cual es primo), un arreglo 
$A$ de $N$ matrices en $Z_p$ (con todas las matrices son de $3 \times 3$), 
y un entero $L$ ($1 <= L <= N$), determinar si existe algún subarreglo 
de longitud exactamente $L$ cuyo producto matricial 
sea igual a $M$. 

Cabe notar que con subarreglo nos referimos a que debe ser una 
subsecuencia contigua del arreglo original. 

Para una instancia de este problema, se pide devolver ``SI'' en 
caso de que exista algún subarreglo de largo $L$ cuyo producto sea $M$, o devolver 
``NO'' en caso contrario. Cada instancia debe ser resuelta con complejidad temporal 
$O(N log N)$, con $N$ 
la cantidad de matrices en el arreglo original. 

\subsection{Soluciones al problema}
\subsubsection{Observaciones}

Primero anotamos algunas observaciones respecto del problema, que serán claves a la
hora de plantear soluciones: 
\begin{enumerate}
    \item Todas las matrices son de $3 \times 3$, de modo que los productos siempre pueden 
    hacerse (es decir, las dimensiones de las matrices coinciden). Más aún, al ser matrices 
    de tamaño fijo, podemos considerar que hacer el producto entre 2 matrices tiene 
    complejidad $O(1)$. 
    \item Aunque las matrices pertenecen a $Z_p$ con $p$ primo, 
    no podemos plantear una solución que utilice algún tipo de inverso de las matrices. 
    De modo que no será viable un algoritmo que asuma que las matrices son inversibles para 
    así ``dividir'' matrices (o multiplicar por el inverso). Por tanto no tenemos inverso para la 
    operación de multiplicar matrices. De sí tenerlo, el problema podría ser resuelto con 
    otras complejidades aún mejores incluso. 
\end{enumerate}

Existen varios posibles algoritmos para resolver este problema, basados en Divide \& Conquer, 
Programación Dinámica, y estructuras más avanzadas aún no vistas en la materia. La solución que 
planteamos en este trabajo estará más bien basada en programación dinámica, consta de calcular 
los productos de 
todos los subarreglos de largo exactamente $L$ eficientemente y verificar si alguno de ellos 
es igual a $M$. \\

Para esto, separamos el algoritmo en 2 partes:
\begin{enumerate}
\item Un precómputo 
\item Cálculo de los productos de los subarreglos de largo $L$
\end{enumerate}

\subsubsection{Algoritmo: precómputo}

Llamaremos $A$ al arreglo original de las $N$ matrices. 
Sea $K$ el máximo entero no negativo tal que $2^K <= N$, entonces $K \in O(log N)$. Crearemos un arreglo 
bidimensional de matrices llamado \texttt{productos[][]} de tamaño $N \times (K+1)$, de modo que 
\texttt{productos[][]} tiene tamaño $O(N log N)$. 

Lo que querremos almacenar en \texttt{productos[i][j]} será \textbf{el producto del subarreglo que 
comienza en $A_i$ de longitud hasta $2^j$} (es decir, $A_i \times A_{i+1} \times ... \times A_{i+2^j}$). 

Cabe notar que en el caso de que $i+2^j$ exceda al tamaño del arreglo ($N$), 
\texttt{productos[i][j]} contendrá el producto desde $A_i$ hasta 
la última matriz $A_n$ (esto será así, por ejemplo, para todos los valores \texttt{productos[N][j]} dado 
que ya empiezan en la matriz $A_n$). \\

Si tenemos por ejemplo 4 matrices, $A_0, A_1, A_2, A_3$, lo que 
querremos calcular en \texttt{productos[][]} sería lo siguiente (como tenemos $N=4$ 
matrices, $K$ sería 2 en este caso):\\

\begin{table}[h!]
\begin{center}
\begin{tabular}{l l}
\texttt{productos[0][0]} = &$A_0$\\
\texttt{productos[1][0]} = &$A_1$\\
\texttt{productos[2][0]} = &$A_2$\\
\texttt{productos[3][0]} = &$A_3$\\
\texttt{productos[0][1]} = &$A_0 \times A_1$\\
\texttt{productos[1][1]} = &$A_1 \times A_2$\\
\texttt{productos[2][1]} = &$A_2 \times A_3$\\
\texttt{productos[3][1]} = &$A_3$\\
\texttt{productos[0][2]} = &$A_0 \times A_1 \times A_2 \times A_3$\\
\texttt{productos[1][2]} = &$A_1 \times A_2 \times A_3$\\
\texttt{productos[2][2]} = &$A_2 \times A_3$\\
\texttt{productos[3][2]} = &$A_3$
\end{tabular}
\end{center}
\caption{Ejemplo del arreglo \texttt{productos[][]}}
\end{table}

Ahora, si bien necesitamos calcular $O(N log N)$ valores en \texttt{productos[][]}, 
si para cada uno de ellos hacemos todos los productos de las matrices involucradas, 
podríamos estar haciendo $O(N)$ productos solo para un valor, y no sería aceptable 
para la complejidad que queremos lograr. Pero podemos usar programación dinámica para 
calcular los valores de \texttt{productos[][]} de un determinado exponente, en base 
a los de exponentes más chicos.\\

Definimos la siguiente recursión para calcular los valores de \texttt{productos[][]}: 

\begin{align*}
productos[i][j] =
	&\begin{cases}
		A_i & \text{si $j=0$} \\
		productos[i][j-1] \times productos[i+2^{j-1}][j-1] & \text{si $j>0 \wedge i+2^{j-1}<N$} \\
		productos[i][j-1] & \text{caso contrario} \\
	\end{cases} \\
\end{align*}

Con esto queremos decir lo siguiente: 
\begin{itemize}
\item Los productos con $j=0$ son los de longitud $2^0=1$, es decir, 
son simplemente $A_i$. Son nuestro caso base. 
\item Si $j>0$, la idea es que podemos formar el producto de largo $2^j$ 
usando 2 productos ya calculados de largo $2^{j-1}$. Esto tiene sentido 
porque $2 \times 2^{j-1} = 2^j$. Es decir, que para conseguir el producto 
que comienza en $i$ de largo $2^j$ deberíamos usar: 
    \begin{itemize}
    \item $X:$ el que comienza en $i$ de largo $2^{j-1}$, e 
    \item $Y:$ el que comienza exactamente luego de donde termina $X$, también de largo 
    $2^{j-1}$. Como conocemos $j$, sabemos que $Y$ comenzará en $i+2^{j-1}$.
    \end{itemize}
\end{itemize}

De esta manera, obteniendo $X$ e $Y$ correctamente, no habrá solapamiento entre ellos 
y tampoco dejaremos elementos de $A$ fuera, y podremos calcular \texttt{productos[i][j]} 
como $X \times Y$. \\

En el ejemplo anterior tendríamos lo siguiente para el caso de calcular \texttt{productos[0][2]}:

$$\underset{productos[0][2]}{\underbrace{\overset{productos[0][1]}{\overbrace{A_0 \times A_1}} \times \overset{productos[2][1]}{\overbrace{A_2 \times A_3}}}}$$

Puede ocurrir que no exista $Y$, porque el índice en el cual debería comenzar $Y$ 
($i+2^{j-1}$) caiga fuera del arreglo. En este caso, puede verse que 
solo necesitamos $X$ para conseguir \texttt{productos[i][j]}, porque quiere decir que 
el producto $X$ ya incluye a la última matriz de $A$ ($A_{n-1}$), 
de modo que no hay más matrices para agregar. \\

Si calculamos y almacenamos los valores \texttt{productos[][]} en orden 
creciente de $j$ (es decir, de la longitud de los subarreglos), 
al momento de calcular \texttt{productos[i][j]} 
ya tendremos los de \texttt{j-1}, que son los que necesitamos. Calcular cada uno de estos es entonces, 
usar una de las matrices dadas, o multiplicar 2 matrices que ya calculamos, de modo que 
cada valor es $O(1)$. Como vimos antes, \texttt{productos[][]} tiene tamaño $O(N log N)$, 
de modo que todo el precómputo lleva $O(N log N)$. 

\subsubsection{Algoritmo: cálculo de los subarreglos de longitud $L$}

\newpage
\subsection{Código de la solución}
\lstinputlisting[numbers = left]{../src/smithers/smithers.cpp}
