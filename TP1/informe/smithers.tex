\newpage{}
\section{El error de Smithers}
\subsection{Descripción del problema}
Dadas una matriz $M\in Z_p$ ($p$ es 10007, el cual es primo), un arreglo 
de N matrices en $Z_p$ (todas las matrices son de $3 \times 3$), 
y un entero $L$ ($1 <= L <= N$), determinar si existe algún subarreglo 
de longitud exactamente $L$ cuyo producto matricial 
sea igual a $M$. 

Cabe notar que con subarreglo nos referimos a que debe ser una 
subsecuencia contigua del arreglo original. 

Para una instancia de este problema, se pide sólamente devolver ``SI'' en 
caso de que exista algún subarreglo de largo $L$ cuyo producto sea $M$, o devolver 
``NO'' en caso contrario. Cada instancia debe ser resuelta con complejidad temporal 
$O(N log N)$, con $N$ 
la cantidad de matrices en el arreglo original. 

\subsection{Soluciones al problema}
\subsubsection{Observaciones}

Primero anotamos algunas observaciones respecto del problema, que serán claves a la
hora de plantear soluciones: 
\begin{enumerate}
    \item Todas las matrices son de $3 \times 3$, de modo que los productos siempre pueden 
    hacerse (es decir, las dimensiones de las matrices coinciden). Más aún, al ser matrices 
    de tamaño fijo, podemos considerar que hacer el producto entre 2 matrices tiene 
    complejidad $O(1)$. 
    \item No se nos garantiza que las matrices sean inversibles. Si bien, las matrices 
    pertenecen a $Z_p$ con $p$ primo, podríamos tener una matriz directamente nula. 
    De modo que no será viable un algoritmo que asuma que las matrices son inversibles para 
    así ``dividir'' matrices (o multiplicar por el inverso). De modo que no tenemos inverso para la 
    operación de multiplicar matrices. De sí tenerlo, el problema podría ser resuelto con 
    otras complejidades aún mejores incluso. 
\end{enumerate}

Existen varios posibles algoritmos para resolver este problema, basados en Divide \& Conquer, 
Programación Dinámica, y estructuras más avanzadas aún no vistas en la materia. La solución que 
planteamos en este trabajo estará más bien basada en programación dinámica, consta de calcular 
los productos de 
todos los subarreglos de largo exactamente $L$ eficientemente y verificar si alguno de ellos 
es igual a $M$. \\

\subsubsection{Algoritmo: precómputo}

Llamaremos $A$ al arreglo original de las $N$ matrices. 
Sea $K$ el máximo natural tal que $2^K <= N$, entonces $K \in O(log N)$. Crearemos un arreglo 
bidimensional de matrices llamado \texttt{productos[][]} de tamaño $N \times K$, de modo que 
\texttt{productos[][]} tiene tamaño $O(N log N)$. 

Lo que querremos almacenar en \texttt{productos[i][j]} será \textbf{el producto del subarreglo que 
comienza en $A_i$ de longitud hasta $2^j$} (es decir, $A_i \times A_{i+1} \times ... \times A_{i+2^j}$). 

Cabe notar que en el caso de que $i+2^j$ exceda al tamaño del arreglo ($N$), 
\texttt{productos[i][j]} contendrá el producto desde $A_i$ hasta 
la última matriz $A_n$ (esto será así, por ejemplo, para todos los valores \texttt{productos[N][j]} dado 
que ya empiezan en la matriz $A_n$). \\

Ahora definimos la siguiente recursión para calcular los valores de \texttt{productos[][]}: 

\begin{align*}
productos[i][j] =
	&\begin{cases}
		A_i & \text{si $j=0$} \\
		productos[i][j-1] \times productos[i+2^{j-1}][j-1] & \text{si $j>0$ y $i+2^{j-1}<=N$} \\
		productos[i][j-1] & \text{caso contrario} \\
	\end{cases} \\
\end{align*}

Con esto queremos decir lo siguiente: 
\begin{itemize}
\item Los productos con $j=0$ son los de longitud $2^0=1$, es decir, 
son simplemente $A_i$. Son nuestro caso base. 
\item Si $j>0$, la idea es que podamos formar el producto de largo $2^j$ 
usando 2 productos ya calculados de largo $2^{j-1}$. Esto tiene sentido 
porque $2 \times 2^{j-1} = 2^j$. Es decir, que para conseguir el producto 
que comienza en $i$ de largo $2^j$ deberíamos usar: 
    \begin{itemize}
    \item $X:$ el que comienza en $i$ de largo $2^{j-1}$, e 
    \item $Y:$ el que comienza exactamente luego de donde termina $X$, también de largo 
    $2^{j-1}$. Como conocemos $j$, sabemos que $Y$ comenzará en $i+2^{j-1}$.
    \end{itemize}
\end{itemize}

De esta manera, obteniendo $X$ e $Y$ correctamente, no habrá solapamiento entre ellos 
y tampoco dejaremos elementos de $A$ fuera, y podremos calcular \texttt{productos[i][j]} 
como $X \times Y$. 

Puede ocurrir que $Y$ no exista, porque el índice en el cual comience este producto 
($i+2^{j-1}$) caiga fuera del arreglo, o sea, que sea mayor a $N$. En este caso, 
solo necesitamos $X$ para conseguir \texttt{productos[i][j]}, porque quiere decir que 
el producto $X$ ya incluye a $A_n$, de modo que no hay más matrices para agregar. \\

Si calculamos y almacenamos los valores \texttt{productos[][]} en orden 
creciente de $j$ (es decir, de la longitud), al momento de calcular \texttt{productos[i][j]} 
ya tendremos los de \texttt{j-1}, que son los que necesitamos. Calcular cada uno de estos es entonces, 
usar una de las matrices dadas, o multiplicar 2 matrices que ya calculamos, de modo que 
cada valor es $O(1)$. Como vimos antes, \texttt{productos[][]} tiene tamaño $O(N log N)$, 
de modo que todo el precómputo lleva $O(N log N)$. 

\subsubsection{Algoritmo: cálculo de los subarreglos de longitud $L$}

\newpage
\subsection{Código de la solución}
\lstinputlisting[numbers = left]{../src/smithers/smithers.cpp}
